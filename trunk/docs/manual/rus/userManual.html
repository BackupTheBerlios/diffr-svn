<html>
<head>
<title>Руководство пользователя</title>
</head>
<body>
<h1>Diffr6</h1>
<h2>Руководство пользователя</h1>

<h5>Содержание</h3>
<a href="#about">Что это такое<a><br>
<a href="#start">Запуск программы<a><br>
<a href="#window">Окно программы<a><br>
<a href="#surface">Как задать поверхность<a><br>
<a href="#incField">Как задать падающее поле<a><br>
<a href="#algorithm">Как задать параметры алгоритма<a><br>
<a href="#run">Как запустить на выполнение<a><br>
<a href="#result">Как посмотреть, что получилось<a><br>
<a href="#newAlg"><h5>Как добавить свой алгоритм</h5><a>
<a href="#newAlg2">Как написать класс алгоритма<a><br>

<hr>

<a name=about>
<h5>Что это такое</h5>

<p>
Двумерные задачи дифракции световых, электромагнитных и звуковых волн описываются хорошо известным уравнением Гельмгольца с различными дополнительными условиями на границах раздела сред и условиями на поведение поля в бесконечности.
</p>
<p>
Особенностью этих задач является то, что кроме нескольких вырожденных случаев у этих задач нет аналитических решений. В настоящее время разработано большое количество численных и асимптотических методов решения этих задач. Эти методы являются разнородными, зависят от различных дополнительных параметров и предположений, «работают» только в определенном диапазоне параметров физической задачи, могут вычислять не все характеристики решения.
</p>
<p>
В мире имеется большое количество исследователей и научных школ, развивающих свои методы решения двумерных задач дифракции. Однако, в силу разнородности существующих алгоритмов и программ, для решения конкретной задачи оказывается крайне сложно найти подходящий метод, по тем же причинам очень сложно сравнить различные существующие алгоритмы.
</p>
<p>
Diffr6 -  единая среда для моделирования двумерных задач дифракции. В этой среде исследователи могут добавлять свои алгоритмы и моделировать при помощи них задачи дифракции.
</p>
<p>
Данная среда позволит для конкретных областей значений параметров задачи дифракции определить наиболее эффективные приближенные методы. Также среда позволит сравнить  различные методы для различных классов параметров физической задачи. 
</p>

<a name=start>
<h5>Запуск программы</h5>
<h6>Запуск .jar файла</h6>
Если программа упакована в jar архив, её можно запустить командой<br>
java -jar diffr.jar<br>

При этом в той дирректории, где находится jar создастся несколько файлов (autosave.task - автосохранение; algorithms.dat - добавленные алгоритмы)
<h6>Запуск .class файла</h6>
Если программа не упакована в jar, то надо запустить класс de.berlios.diffr.Init с параметром "../"
(из каталога ./bin выполнить команду
java –cp “.” de.belios.diffr.Init ../)
В Windows это делает файл ./start.bat

<a name=window>
<h5>Окно программы</h3>
После запуска вы должны увидеть вот это:

<br>
<img src="../images/window.jpg">
<br>

Справа находится изображение <dfn>поверхности</dfn> и <dfn>падающего поля</dfn>. Левая часть состоит из трёх вкладок: Input data, Result и Algorithm.
Вкладка Input data используется для изменения входных данных. В нутри неё ещё две вкладки – Surface  (Для изменения <dfn>поверхности</dfn>) и Incident field (Для изменения <dfn>падающего поля</dfn>).
Вкадка Result используется для просмотра результата вычислений. Состоит из Reflected field (Отражённое поле), Passed field (Прошедшее поле) и Surface current (Токи в поверхности). Если выбранный <dfn>алгоритм</dfn> не умеет считать какую-нибудь из частей результата, вкладка для неё показываться не будет.
Вкладка Algorithm используется для выбора алгоритма и изменения его параметров.

<a name=surface>
<h5>Как задать поверхность</h5>

Поверхность обязательно периодическая и задаётся коэффицентами Фурье.
Чтобы поменяеть её надо выбрать вкладку InputData/Surface.<br>
Далее можно выбирать вкладку Shape для изменения формы и периода.<br>
period - периуд поверхности<br>
shift - насколько поверхность приподнята над осью координат<br>
Number of Fourier coefficients - количество коэффицентов Фурье<br>
Далее идёт таблица, задающая сами коэффиценты
<br>
Любое изменение сразу отразится на изображении поверхности справа.
<br>
Все размеры указываются в сантиметрах

<br>
<img src="../images/surfaceShape.jpg">
<br>

Для того, чтобы поменять проводимость поверхности надо выбрать вкладку Conductivity<br>
Проводимость на картинке справа не изображается

<br>
<img src="../images/surfaceConductivity.jpg">
<br>

<a name=incField>
<h5>Как задать падающее поле</h5>
Надо выбрать вкладку InputData/Incident Wave<br>
angle - угол к вертикали (в градусах)<br>
length - длина волны в сантиметрах (на картинке справа изображается длиной стрелочки)<br>
amplitude - амплитуда (комплексное число)<br>
polarization - поляризация (выбрать E или H)<br>

<br>
<img src="../images/incidentWave.jpg">
<br>

<a name=algorithm>
<h5>Как задать параметры алгоритма</h5>
Надо выбрать вкладку Algorithm<br>
В верхней части есть экрана выпадающий список с названиями существующих алгоритмов<br>
Далее идут параметры алгоритма

<br>
<img src="../images/algorithm.jpg">
<br>

<a name=run>
<h5>Как запустить задачу на выполнение</h5>
Для запуска в меню с верху выберите Task/Start

<br>
<img src="../images/run.jpg">
<br>

Тогда в низу экрана надпись<br>
State:<br>
Result isn`t calculated<br>
<br>
Заменится на<br>
State:<br>
Task is solving...<br>
<br>
А затем на<br>
State:<br>
Result is calculated<br>
<br>

<a name=result>
<h5>Как посмотреть, что получилось</h5>
Выберите вкладку Result.<br>
Если состояние (строчка внизу окошка) что-то кроме "Result is calculated", то результат отображаться не будет.<br>
Далее есть несколько вкладок:<br>
Reflected Field - отраженное поле. В нём имеются вложенные вкладки Graphical view и Text view

<br>
<img src="../images/resFieldGraph.jpg">
<br>

Красная стрелочка - падающее поле, зелёные - отражённое. Длины стрелочек пропорциональны амплитудам волн.

<br>
<img src="../images/resFieldText.jpg">
<br>

Surface Current - токи в поверхности. Тоже состоит из Graphical view и Text view

<br>
<img src="../images/resCurrentGraph.jpg">
<br>
<img src="../images/resCurrentText.jpg">
<br>

<a name=newAlg>
<h3>Как добавить новый алгоритм</h3>
Для того, чтобы добавть свой алгоритм нужно написать класс, унаследованный от de.berlios.diffr.algorithms.AbstractAlgorithm, и положить в пакет de.berlios.diffr.algorithms.addedAlgorithms
 (Дирректория bin/de/berlios/diffr/algorithms/addedAlgorithms/)<br>
Затем запустите diffr и выберите в меню Algorithms/Add algorithm

<br>
<img src="../images/addAlgorithm.jpg">
<br>

Надо указать название, автора, версию и название класса<br>
(SleepAlgorithm - это алгоритм, который ничего не считает, а просто ждёт несколько секунд. Он используется только для тестирования. Класс SleepAlgorithm.class уже лежит в требуемой дирректории)

<br><br>
Чтобы удалить алгоритм выберите в меню Algorithms/Remove algorithm

<br>
<img src="../images/removeAlgorithm.jpg">
<br>

<a name=newAlg2>
<h5>Как написать класс алгоритма</h5>

В классе алгоритма надо реализовать методы:
public Result calculate(InputData inputData) throws Exception<br>
public Algorithm clone()<br>
<br>
inputData - обезразмеренные входные данные
из него можно извлечь все параметры задачи, например:<br>
double shift = inputData.getSurface().getShape().getShift();
<br>
В конструктор Result надо дать ReflectedField(отражённое поле), PassedField(прошедшее поле), SurfaceCurrent(токи в поверхности), double(точность)<br>
Вместо части параматров можно дать пустые ссылки - тогда соответствующие вкладки результата отображаться не будут.<br>
<br>
Кроме того надо обязательно реализовать конструктор:<br>
<code>
	public 'Название класса'(AlgorithmType algorithmType) {<br>
		super(algorithmType);<br>
		parameters = new DataString['количество параметров алгоитма'];<br>
		parameters[0] = new DataString("Описание параметра1", 'Значение по умолчанию');<br>
		parameters[1] = new DataString("Описание параметра2", 'Значение по умолчанию');<br>
		...
	}<br>
</code><br>
'Значение по умолчанию' - это одно из new Long(значение), new Integer(значение), new Double(значение).<br>
<br>
Затем перед запуском алгоритма значения в массиве parametres будут заменены на указанные пользователем.<br>
Извлечь их можно так: (Long или Integer или Double)parameters[0].getValue()<br>
<br>
Таким образом ваш алгоритм будет выглядеть так:
<br>
<code>
package de.berlios.diffr.algorithms.addedAlgorithms;<br>
<br>
import de.berlios.diffr.*;<br>
import de.berlios.diffr.algorithms.*;<br>
import de.berlios.diffr.inputData.InputData;<br>
import de.berlios.diffr.result.Result;<br>
<br>
public class MyAlgorithm extends AbstractAlgorithm {<br>
	private static final long serialVersionUID = 1L;<br>
	public MyAlgorithm(AlgorithmType algorithmType) {<br>
		super(algorithmType);<br>
		parameters = new DataString[0];<br>
	}<br>
	public Algorithm clone() {<br>
		MyAlgorithm r = new MyAlgorithm(super.getAlgorithmType());<br>
		r.parameters = parameters.clone();<br>
		return r;<br>
	}<br>
	public Result calculate(InputData inputData) throws Exception {<br>
		ReflectedField reflectedField;<br>
		SurfaceCurrent surfaceCurrent;<br>
		double energeticImperfection;<br>
...<br>
... Ваш код<br>
...<br>
		return new Result(reflectedField, null, surfaceCurrent, energeticImperfection);<br>
	}<br>
}<br>
</code>

</body>
</html>